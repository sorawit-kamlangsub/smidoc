//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError, AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from "axios";

import * as dayjs from "dayjs";

export class DocumentClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * แสดงข้อมูล เอกสารทั้งหมด
     * @param page (optional)
     * @param recordsPerPage (optional)
     * @param documentTypeId (optional)
     * @param documentSubTypeId (optional)
     * @param searchIndex (optional)
     * @param sortColumn (optional)
     * @param ordering (optional)
     * @return Success
     */
    getDocumentAll(
        page?: number | undefined,
        recordsPerPage?: number | undefined,
        documentTypeId?: number | undefined,
        documentSubTypeId?: number | undefined,
        searchIndex?: string | undefined,
        sortColumn?: string | undefined,
        ordering?: string | undefined,
        cancelToken?: CancelToken | undefined
    ): Promise<DocumentResponseDtoListServiceResponse> {
        let url_ = this.baseUrl + "/document?";
        if (page === null) throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined) url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null) throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        if (documentTypeId === null) throw new Error("The parameter 'documentTypeId' cannot be null.");
        else if (documentTypeId !== undefined)
            url_ += "DocumentTypeId=" + encodeURIComponent("" + documentTypeId) + "&";
        if (documentSubTypeId === null) throw new Error("The parameter 'documentSubTypeId' cannot be null.");
        else if (documentSubTypeId !== undefined)
            url_ += "DocumentSubTypeId=" + encodeURIComponent("" + documentSubTypeId) + "&";
        if (searchIndex === null) throw new Error("The parameter 'searchIndex' cannot be null.");
        else if (searchIndex !== undefined) url_ += "SearchIndex=" + encodeURIComponent("" + searchIndex) + "&";
        if (sortColumn === null) throw new Error("The parameter 'sortColumn' cannot be null.");
        else if (sortColumn !== undefined) url_ += "SortColumn=" + encodeURIComponent("" + sortColumn) + "&";
        if (ordering === null) throw new Error("The parameter 'ordering' cannot be null.");
        else if (ordering !== undefined) url_ += "Ordering=" + encodeURIComponent("" + ordering) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "text/plain",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processGetDocumentAll(_response);
            });
    }

    protected processGetDocumentAll(response: AxiosResponse): Promise<DocumentResponseDtoListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = resultData200;
            return Promise.resolve<DocumentResponseDtoListServiceResponse>(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DocumentResponseDtoListServiceResponse>(null as any);
    }

    /**
     * แสดงข้อมูล เอกสาร จากคำค้นหา
     * @param page (optional)
     * @param recordsPerPage (optional)
     * @param filter (optional) คำค้นหา
     * @param sortColumn (optional)
     * @param ordering (optional)
     * @return Success
     */
    getDocumentFilter(
        page?: number | undefined,
        recordsPerPage?: number | undefined,
        filter?: string | undefined,
        sortColumn?: string | undefined,
        ordering?: string | undefined,
        cancelToken?: CancelToken | undefined
    ): Promise<DocumentFilterResponseDtoListServiceResponse> {
        let url_ = this.baseUrl + "/document/filter?";
        if (page === null) throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined) url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null) throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        if (filter === null) throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined) url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        if (sortColumn === null) throw new Error("The parameter 'sortColumn' cannot be null.");
        else if (sortColumn !== undefined) url_ += "SortColumn=" + encodeURIComponent("" + sortColumn) + "&";
        if (ordering === null) throw new Error("The parameter 'ordering' cannot be null.");
        else if (ordering !== undefined) url_ += "Ordering=" + encodeURIComponent("" + ordering) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "text/plain",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processGetDocumentFilter(_response);
            });
    }

    protected processGetDocumentFilter(response: AxiosResponse): Promise<DocumentFilterResponseDtoListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = resultData200;
            return Promise.resolve<DocumentFilterResponseDtoListServiceResponse>(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DocumentFilterResponseDtoListServiceResponse>(null as any);
    }

    /**
     * แสดงข้อมูล เอกสาร จากรหัสเอกสาร
     * @param documentId รหัสเอกสาร
     * @return Success
     */
    getDocumentById(
        documentId: string,
        cancelToken?: CancelToken | undefined
    ): Promise<DocumentByIdResponseDtoServiceResponse> {
        let url_ = this.baseUrl + "/document/{documentId}";
        if (documentId === undefined || documentId === null)
            throw new Error("The parameter 'documentId' must be defined.");
        url_ = url_.replace("{documentId}", encodeURIComponent("" + documentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "text/plain",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processGetDocumentById(_response);
            });
    }

    protected processGetDocumentById(response: AxiosResponse): Promise<DocumentByIdResponseDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = resultData200;
            return Promise.resolve<DocumentByIdResponseDtoServiceResponse>(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DocumentByIdResponseDtoServiceResponse>(null as any);
    }

    /**
     * แสดงข้อมูล Documentfile โดยค้นหาจาก DocumentId
     * @param documentId รหัสเอกสาร
     * @param page (optional)
     * @param recordsPerPage (optional)
     * @param sortColumn (optional)
     * @param ordering (optional)
     * @param isShow (optional)
     * @return Success
     */
    getDocumentFileByDocumentId(
        documentId: string,
        page?: number | undefined,
        recordsPerPage?: number | undefined,
        sortColumn?: string | undefined,
        ordering?: string | undefined,
        isShow?: boolean | undefined,
        cancelToken?: CancelToken | undefined
    ): Promise<DocumentFileResponseDtoListServiceResponse> {
        let url_ = this.baseUrl + "/document/{documentId}/documentFile?";
        if (documentId === undefined || documentId === null)
            throw new Error("The parameter 'documentId' must be defined.");
        url_ = url_.replace("{documentId}", encodeURIComponent("" + documentId));
        if (page === null) throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined) url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null) throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        if (sortColumn === null) throw new Error("The parameter 'sortColumn' cannot be null.");
        else if (sortColumn !== undefined) url_ += "SortColumn=" + encodeURIComponent("" + sortColumn) + "&";
        if (ordering === null) throw new Error("The parameter 'ordering' cannot be null.");
        else if (ordering !== undefined) url_ += "Ordering=" + encodeURIComponent("" + ordering) + "&";
        if (isShow === null) throw new Error("The parameter 'isShow' cannot be null.");
        else if (isShow !== undefined) url_ += "isShow=" + encodeURIComponent("" + isShow) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "text/plain",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processGetDocumentFileByDocumentId(_response);
            });
    }

    protected processGetDocumentFileByDocumentId(
        response: AxiosResponse
    ): Promise<DocumentFileResponseDtoListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = resultData200;
            return Promise.resolve<DocumentFileResponseDtoListServiceResponse>(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DocumentFileResponseDtoListServiceResponse>(null as any);
    }

    /**
     * แสดงข้อมูล DocumentIndexValue โดยค้นหาจาก DocumentId
     * @param documentId รหัสเอกสาร
     * @param page (optional)
     * @param recordsPerPage (optional)
     * @param sortColumn (optional)
     * @param ordering (optional)
     * @return Success
     */
    getDocumentIndexValueByDocumentId(
        documentId: string,
        page?: number | undefined,
        recordsPerPage?: number | undefined,
        sortColumn?: string | undefined,
        ordering?: string | undefined,
        cancelToken?: CancelToken | undefined
    ): Promise<DocumentIndexValueByDocumentIdResponseDtoListServiceResponse> {
        let url_ = this.baseUrl + "/document/{documentId}/documentIndexValue?";
        if (documentId === undefined || documentId === null)
            throw new Error("The parameter 'documentId' must be defined.");
        url_ = url_.replace("{documentId}", encodeURIComponent("" + documentId));
        if (page === null) throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined) url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (recordsPerPage === null) throw new Error("The parameter 'recordsPerPage' cannot be null.");
        else if (recordsPerPage !== undefined)
            url_ += "RecordsPerPage=" + encodeURIComponent("" + recordsPerPage) + "&";
        if (sortColumn === null) throw new Error("The parameter 'sortColumn' cannot be null.");
        else if (sortColumn !== undefined) url_ += "SortColumn=" + encodeURIComponent("" + sortColumn) + "&";
        if (ordering === null) throw new Error("The parameter 'ordering' cannot be null.");
        else if (ordering !== undefined) url_ += "Ordering=" + encodeURIComponent("" + ordering) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "text/plain",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processGetDocumentIndexValueByDocumentId(_response);
            });
    }

    protected processGetDocumentIndexValueByDocumentId(
        response: AxiosResponse
    ): Promise<DocumentIndexValueByDocumentIdResponseDtoListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = resultData200;
            return Promise.resolve<DocumentIndexValueByDocumentIdResponseDtoListServiceResponse>(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DocumentIndexValueByDocumentIdResponseDtoListServiceResponse>(null as any);
    }

    /**
     * แสดงข้อมูล documentFileById โดยค้นหาจาก DocumentFileId
     * @param documentFileId รหัสเอกสาร
     * @return Success
     */
    getDocumentFileById(
        documentFileId: string,
        cancelToken?: CancelToken | undefined
    ): Promise<DocumentFileResponseDtoServiceResponse> {
        let url_ = this.baseUrl + "/document/{documentFileId}/link/documentfile";
        if (documentFileId === undefined || documentFileId === null)
            throw new Error("The parameter 'documentFileId' must be defined.");
        url_ = url_.replace("{documentFileId}", encodeURIComponent("" + documentFileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "text/plain",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processGetDocumentFileById(_response);
            });
    }

    protected processGetDocumentFileById(response: AxiosResponse): Promise<DocumentFileResponseDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = resultData200;
            return Promise.resolve<DocumentFileResponseDtoServiceResponse>(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DocumentFileResponseDtoServiceResponse>(null as any);
    }

    /**
     * แสดงข้อมูล เอกสาร ตามการค้นหา
     * @param mainIndex (optional)
     * @param documentSubTypeId (optional)
     * @param documentCode (optional)
     * @return Success
     */
    getDocumentSearch(
        mainIndex?: string | undefined,
        documentSubTypeId?: number | undefined,
        documentCode?: string | undefined,
        cancelToken?: CancelToken | undefined
    ): Promise<DocumentSearchResponseDtoListServiceResponse> {
        let url_ = this.baseUrl + "/document/search?";
        if (mainIndex === null) throw new Error("The parameter 'mainIndex' cannot be null.");
        else if (mainIndex !== undefined) url_ += "MainIndex=" + encodeURIComponent("" + mainIndex) + "&";
        if (documentSubTypeId === null) throw new Error("The parameter 'documentSubTypeId' cannot be null.");
        else if (documentSubTypeId !== undefined)
            url_ += "DocumentSubTypeId=" + encodeURIComponent("" + documentSubTypeId) + "&";
        if (documentCode === null) throw new Error("The parameter 'documentCode' cannot be null.");
        else if (documentCode !== undefined) url_ += "DocumentCode=" + encodeURIComponent("" + documentCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "text/plain",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processGetDocumentSearch(_response);
            });
    }

    protected processGetDocumentSearch(response: AxiosResponse): Promise<DocumentSearchResponseDtoListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = resultData200;
            return Promise.resolve<DocumentSearchResponseDtoListServiceResponse>(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DocumentSearchResponseDtoListServiceResponse>(null as any);
    }

    /**
     * แสดงข้อมูล เอกสาร สาธารณะ ตามการค้นหา
     * @return Success
     */
    getDocumentPublicDocLink(
        documentId: string,
        cancelToken?: CancelToken | undefined
    ): Promise<DocumentFilePublicResponseDtoServiceResponse> {
        let url_ = this.baseUrl + "/document/{documentId}/link/documentfile/public";
        if (documentId === undefined || documentId === null)
            throw new Error("The parameter 'documentId' must be defined.");
        url_ = url_.replace("{documentId}", encodeURIComponent("" + documentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "text/plain",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processGetDocumentPublicDocLink(_response);
            });
    }

    protected processGetDocumentPublicDocLink(
        response: AxiosResponse
    ): Promise<DocumentFilePublicResponseDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = resultData200;
            return Promise.resolve<DocumentFilePublicResponseDtoServiceResponse>(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DocumentFilePublicResponseDtoServiceResponse>(null as any);
    }

    /**
     * แสดงข้อมูล เอกสาร ด้วย MainIndexList
     * @param mainindexs (optional)
     * @return Success
     */
    getDocumentByMainIndexList(
        mainindexs?: string[] | undefined,
        cancelToken?: CancelToken | undefined
    ): Promise<DocumentByIdResponseDtoListServiceResponse> {
        let url_ = this.baseUrl + "/document/mainindex/list?";
        if (mainindexs === null) throw new Error("The parameter 'mainindexs' cannot be null.");
        else if (mainindexs !== undefined)
            mainindexs &&
                mainindexs.forEach((item) => {
                    url_ += "mainindexs=" + encodeURIComponent("" + item) + "&";
                });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "text/plain",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processGetDocumentByMainIndexList(_response);
            });
    }

    protected processGetDocumentByMainIndexList(
        response: AxiosResponse
    ): Promise<DocumentByIdResponseDtoListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = resultData200;
            return Promise.resolve<DocumentByIdResponseDtoListServiceResponse>(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DocumentByIdResponseDtoListServiceResponse>(null as any);
    }

    /**
     * แสดงข้อมูล เอกสาร ด้วย DocumentId List
     * @param documentIds (optional)
     * @return Success
     */
    getDocumentByMainIndex(
        documentIds?: string[] | undefined,
        cancelToken?: CancelToken | undefined
    ): Promise<DocumentByIdResponseDtoListServiceResponse> {
        let url_ = this.baseUrl + "/document/documentid/list?";
        if (documentIds === null) throw new Error("The parameter 'documentIds' cannot be null.");
        else if (documentIds !== undefined)
            documentIds &&
                documentIds.forEach((item) => {
                    url_ += "documentIds=" + encodeURIComponent("" + item) + "&";
                });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "text/plain",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processGetDocumentByMainIndex(_response);
            });
    }

    protected processGetDocumentByMainIndex(
        response: AxiosResponse
    ): Promise<DocumentByIdResponseDtoListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = resultData200;
            return Promise.resolve<DocumentByIdResponseDtoListServiceResponse>(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DocumentByIdResponseDtoListServiceResponse>(null as any);
    }
}

export class DocumentUploaderClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Uploadเอกสาร
     * @param documentCode (optional)
     * @param documentId (optional)
     * @param documentSubTypeId (optional)
     * @param mainIndex (optional)
     * @param searchIndex (optional)
     * @param documentIndexId (optional)
     * @param documentIndexValue (optional)
     * @param fileUploads (optional)
     * @return Success
     */
    documentCreate(
        documentCode?: string | undefined,
        documentId?: string | undefined,
        documentSubTypeId?: number | undefined,
        mainIndex?: string | undefined,
        searchIndex?: string | undefined,
        documentIndexId?: number[] | undefined,
        documentIndexValue?: string[] | undefined,
        fileUploads?: FileParameter[] | undefined,
        cancelToken?: CancelToken | undefined
    ): Promise<UploadResponseDtoServiceResponse> {
        let url_ = this.baseUrl + "/Upload/document";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (documentCode === null || documentCode === undefined)
            throw new Error("The parameter 'documentCode' cannot be null.");
        else content_.append("DocumentCode", documentCode.toString());
        if (documentId === null || documentId === undefined)
            throw new Error("The parameter 'documentId' cannot be null.");
        else content_.append("DocumentId", documentId.toString());
        if (documentSubTypeId === null || documentSubTypeId === undefined)
            throw new Error("The parameter 'documentSubTypeId' cannot be null.");
        else content_.append("DocumentSubTypeId", documentSubTypeId.toString());
        if (mainIndex === null || mainIndex === undefined) throw new Error("The parameter 'mainIndex' cannot be null.");
        else content_.append("MainIndex", mainIndex.toString());
        if (searchIndex === null || searchIndex === undefined)
            throw new Error("The parameter 'searchIndex' cannot be null.");
        else content_.append("SearchIndex", searchIndex.toString());
        if (documentIndexId === null || documentIndexId === undefined)
            throw new Error("The parameter 'documentIndexId' cannot be null.");
        else documentIndexId.forEach((item_) => content_.append("DocumentIndexId", item_.toString()));
        if (documentIndexValue === null || documentIndexValue === undefined)
            throw new Error("The parameter 'documentIndexValue' cannot be null.");
        else documentIndexValue.forEach((item_) => content_.append("DocumentIndexValue", item_.toString()));
        if (fileUploads === null || fileUploads === undefined)
            throw new Error("The parameter 'fileUploads' cannot be null.");
        else
            fileUploads.forEach((item_) =>
                content_.append("FileUploads", item_.data, item_.fileName ? item_.fileName : "FileUploads")
            );

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                Accept: "text/plain",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processDocumentCreate(_response);
            });
    }

    protected processDocumentCreate(response: AxiosResponse): Promise<UploadResponseDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = resultData200;
            return Promise.resolve<UploadResponseDtoServiceResponse>(result200);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UploadResponseDtoServiceResponse>(null as any);
    }

    /**
     * Uploadเอกสาร ด้วย DocumentID and DocumentFile
     * @param document (optional)
     * @return Success
     */
    documentFileCreateById(
        documentid: string,
        document?: FileParameter[] | undefined,
        cancelToken?: CancelToken | undefined
    ): Promise<UploadResponseDtoServiceResponse> {
        let url_ = this.baseUrl + "/Upload/{documentid}/documentfile";
        if (documentid === undefined || documentid === null)
            throw new Error("The parameter 'documentid' must be defined.");
        url_ = url_.replace("{documentid}", encodeURIComponent("" + documentid));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (document === null || document === undefined) throw new Error("The parameter 'document' cannot be null.");
        else
            document.forEach((item_) =>
                content_.append("document", item_.data, item_.fileName ? item_.fileName : "document")
            );

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                Accept: "text/plain",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processDocumentFileCreateById(_response);
            });
    }

    protected processDocumentFileCreateById(response: AxiosResponse): Promise<UploadResponseDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = resultData200;
            return Promise.resolve<UploadResponseDtoServiceResponse>(result200);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UploadResponseDtoServiceResponse>(null as any);
    }

    /**
     * @return Success
     */
    documentDelete(
        documentid: string,
        documentfileid: string,
        cancelToken?: CancelToken | undefined
    ): Promise<DeleteResponseDtoServiceResponse> {
        let url_ = this.baseUrl + "/Upload/{documentid}/file/{documentfileid}/delete";
        if (documentid === undefined || documentid === null)
            throw new Error("The parameter 'documentid' must be defined.");
        url_ = url_.replace("{documentid}", encodeURIComponent("" + documentid));
        if (documentfileid === undefined || documentfileid === null)
            throw new Error("The parameter 'documentfileid' must be defined.");
        url_ = url_.replace("{documentfileid}", encodeURIComponent("" + documentfileid));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                Accept: "text/plain",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processDocumentDelete(_response);
            });
    }

    protected processDocumentDelete(response: AxiosResponse): Promise<DeleteResponseDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = resultData200;
            return Promise.resolve<DeleteResponseDtoServiceResponse>(result200);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DeleteResponseDtoServiceResponse>(null as any);
    }

    /**
     * เปลี่ยนสถานะ File ที่ ถูกลบกลับมาใช้งาน
     * @return Success
     */
    reupload(
        documentid: string,
        documentfileid: string,
        cancelToken?: CancelToken | undefined
    ): Promise<UploadResponseDtoServiceResponse> {
        let url_ = this.baseUrl + "/Upload/{documentid}/file/{documentfileid}/delete/reupload";
        if (documentid === undefined || documentid === null)
            throw new Error("The parameter 'documentid' must be defined.");
        url_ = url_.replace("{documentid}", encodeURIComponent("" + documentid));
        if (documentfileid === undefined || documentfileid === null)
            throw new Error("The parameter 'documentfileid' must be defined.");
        url_ = url_.replace("{documentfileid}", encodeURIComponent("" + documentfileid));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                Accept: "text/plain",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processReupload(_response);
            });
    }

    protected processReupload(response: AxiosResponse): Promise<UploadResponseDtoServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = resultData200;
            return Promise.resolve<UploadResponseDtoServiceResponse>(result200);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UploadResponseDtoServiceResponse>(null as any);
    }

    /**
     * @return Success
     */
    tranferAWSJob(cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Upload/TranferAWSJob";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {},
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processTranferAWSJob(_response);
            });
    }

    protected processTranferAWSJob(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            // const _responseText = response.data;
            return Promise.resolve<void>(null as any);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    deleteFileLocalJob(cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Upload/DeleteFileLocalJob";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {},
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processDeleteFileLocalJob(_response);
            });
    }

    protected processDeleteFileLocalJob(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            // const _responseText = response.data;
            return Promise.resolve<void>(null as any);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param contentType (optional)
     * @param contentDisposition (optional)
     * @param headers (optional)
     * @param length (optional)
     * @param name (optional)
     * @param fileName (optional)
     * @return Success
     */
    testDocumentFileUploadCreateConsumer(
        documentSubTypeId: number,
        mainIndex: string,
        searchIndex: string,
        contentType?: string | undefined,
        contentDisposition?: string | undefined,
        headers?: { [key: string]: string[] } | undefined,
        length?: number | undefined,
        name?: string | undefined,
        fileName?: string | undefined,
        cancelToken?: CancelToken | undefined
    ): Promise<void> {
        let url_ = this.baseUrl + "/Upload/TestDocumentFileUploadCreateConsumer?";
        if (documentSubTypeId === undefined || documentSubTypeId === null)
            throw new Error("The parameter 'documentSubTypeId' must be defined and cannot be null.");
        else url_ += "DocumentSubTypeId=" + encodeURIComponent("" + documentSubTypeId) + "&";
        if (mainIndex === undefined || mainIndex === null)
            throw new Error("The parameter 'mainIndex' must be defined and cannot be null.");
        else url_ += "MainIndex=" + encodeURIComponent("" + mainIndex) + "&";
        if (searchIndex === undefined || searchIndex === null)
            throw new Error("The parameter 'searchIndex' must be defined and cannot be null.");
        else url_ += "SearchIndex=" + encodeURIComponent("" + searchIndex) + "&";
        if (contentType === null) throw new Error("The parameter 'contentType' cannot be null.");
        else if (contentType !== undefined) url_ += "ContentType=" + encodeURIComponent("" + contentType) + "&";
        if (contentDisposition === null) throw new Error("The parameter 'contentDisposition' cannot be null.");
        else if (contentDisposition !== undefined)
            url_ += "ContentDisposition=" + encodeURIComponent("" + contentDisposition) + "&";
        if (headers === null) throw new Error("The parameter 'headers' cannot be null.");
        else if (headers !== undefined) url_ += "Headers=" + encodeURIComponent("" + headers) + "&";
        if (length === null) throw new Error("The parameter 'length' cannot be null.");
        else if (length !== undefined) url_ += "Length=" + encodeURIComponent("" + length) + "&";
        if (name === null) throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined) url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (fileName === null) throw new Error("The parameter 'fileName' cannot be null.");
        else if (fileName !== undefined) url_ += "FileName=" + encodeURIComponent("" + fileName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {},
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processTestDocumentFileUploadCreateConsumer(_response);
            });
    }

    protected processTestDocumentFileUploadCreateConsumer(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            // const _responseText = response.data;
            return Promise.resolve<void>(null as any);
        } else if (status === 401) {
            const _responseText = response.data;
            return throwException("Unauthorized", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.data;
            return throwException("Forbidden", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class MasterClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * แสดงข้อมูล ประเภทเอกสาร
     * @param documentTypeId (optional)
     * @return Success
     */
    getDocumentType(
        documentTypeId?: number | undefined,
        cancelToken?: CancelToken | undefined
    ): Promise<DocumentTypeResponseDtoListServiceResponse> {
        let url_ = this.baseUrl + "/master/document/type?";
        if (documentTypeId === null) throw new Error("The parameter 'documentTypeId' cannot be null.");
        else if (documentTypeId !== undefined)
            url_ += "DocumentTypeId=" + encodeURIComponent("" + documentTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "text/plain",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processGetDocumentType(_response);
            });
    }

    protected processGetDocumentType(response: AxiosResponse): Promise<DocumentTypeResponseDtoListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = resultData200;
            return Promise.resolve<DocumentTypeResponseDtoListServiceResponse>(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DocumentTypeResponseDtoListServiceResponse>(null as any);
    }

    /**
     * แสดงข้อมูล ประเภทย่อยเอกสาร
     * @param documentTypeId (optional)
     * @param documentSubTypeId (optional)
     * @return Success
     */
    getDocumentSubType(
        documentTypeId?: number | undefined,
        documentSubTypeId?: number | undefined,
        cancelToken?: CancelToken | undefined
    ): Promise<DocumentSubTypeResponseDtoListServiceResponse> {
        let url_ = this.baseUrl + "/master/document/subtype?";
        if (documentTypeId === null) throw new Error("The parameter 'documentTypeId' cannot be null.");
        else if (documentTypeId !== undefined)
            url_ += "DocumentTypeId=" + encodeURIComponent("" + documentTypeId) + "&";
        if (documentSubTypeId === null) throw new Error("The parameter 'documentSubTypeId' cannot be null.");
        else if (documentSubTypeId !== undefined)
            url_ += "DocumentSubTypeId=" + encodeURIComponent("" + documentSubTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "text/plain",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processGetDocumentSubType(_response);
            });
    }

    protected processGetDocumentSubType(
        response: AxiosResponse
    ): Promise<DocumentSubTypeResponseDtoListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = resultData200;
            return Promise.resolve<DocumentSubTypeResponseDtoListServiceResponse>(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DocumentSubTypeResponseDtoListServiceResponse>(null as any);
    }

    /**
     * แสดงข้อมูล เอกสาร จาก รหัสประเภทย่อยเอกสาร
     * @param documentSubTypeId แสดงข้อมูลจาก รหัสประเภทย่อยเอกสาร
     * @return Success
     */
    getDocumentIndex(
        documentSubTypeId: number,
        cancelToken?: CancelToken | undefined
    ): Promise<DocumentIndexResponseDtoListServiceResponse> {
        let url_ = this.baseUrl + "/master/document/index?";
        if (documentSubTypeId === undefined || documentSubTypeId === null)
            throw new Error("The parameter 'documentSubTypeId' must be defined and cannot be null.");
        else url_ += "documentSubTypeId=" + encodeURIComponent("" + documentSubTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                Accept: "text/plain",
            },
            cancelToken,
        };

        return this.instance
            .request(options_)
            .catch((_error: any) => {
                if (isAxiosError(_error) && _error.response) {
                    return _error.response;
                } else {
                    throw _error;
                }
            })
            .then((_response: AxiosResponse) => {
                return this.processGetDocumentIndex(_response);
            });
    }

    protected processGetDocumentIndex(response: AxiosResponse): Promise<DocumentIndexResponseDtoListServiceResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = resultData200;
            return Promise.resolve<DocumentIndexResponseDtoListServiceResponse>(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DocumentIndexResponseDtoListServiceResponse>(null as any);
    }
}

export interface DeleteResponseDto {
    documentId?: string;
    files?: UploadDocumentFilesResponseDto;
}

export interface DeleteResponseDtoServiceResponse {
    data?: DeleteResponseDto;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface DocumentByIdResponseDto {
    documentId?: string | undefined;
    documentCode?: string | undefined;
    mainIndex?: string | undefined;
    searchIndex?: string | undefined;
    documentTypeName?: string | undefined;
    documentSubTypeName?: string | undefined;
    fileCount?: number | undefined;
    documentFiles?: DocumentFileResponseDto[] | undefined;
    documentIndexs?: DocumentIndexValueByDocumentIdResponseDto[] | undefined;
}

export interface DocumentByIdResponseDtoListServiceResponse {
    data?: DocumentByIdResponseDto[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface DocumentByIdResponseDtoServiceResponse {
    data?: DocumentByIdResponseDto;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface DocumentFileLinkResponseDto {
    pathFullDoc?: string | undefined;
}

export interface DocumentFilePublicResponseDto {
    documentId?: string | undefined;
    documentTypeName?: string | undefined;
    documentSubTypeName?: string | undefined;
    fileCount?: number | undefined;
    documentFiles?: DocumentFileLinkResponseDto[] | undefined;
}

export interface DocumentFilePublicResponseDtoServiceResponse {
    data?: DocumentFilePublicResponseDto;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface DocumentFileResponseDto {
    documentFileId?: string | undefined;
    s3IsUploaded?: boolean | undefined;
    s3Bucket?: string | undefined;
    s3Key?: string | undefined;
    physicalPath?: string | undefined;
    fileName?: string | undefined;
    fileURL?: string | undefined;
    pathThumbnailImg?: string | undefined;
    pathFullDoc?: string | undefined;
    isImage?: boolean;
    createdDate?: dayjs.Dayjs | undefined;
    createdByUserId?: number | undefined;
    createByUserCode?: string | undefined;
    createdByUserName?: string | undefined;
    deletedByUserId?: number | undefined;
    deletedByUserCode?: string | undefined;
    deletedByUserName?: string | undefined;
    deletedDate?: dayjs.Dayjs | undefined;
    isActive?: boolean | undefined;
    recoveredDate?: dayjs.Dayjs | undefined;
    recoveredByUserId?: number | undefined;
    recoveredByUserCode?: string | undefined;
    recoveredByUserName?: string | undefined;
    updatedDate?: dayjs.Dayjs | undefined;
}

export interface DocumentFileResponseDtoListServiceResponse {
    data?: DocumentFileResponseDto[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface DocumentFileResponseDtoServiceResponse {
    data?: DocumentFileResponseDto;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface DocumentFilterResponseDto {
    documentId?: string | undefined;
    fileCount?: number | undefined;
    documentSubTypeId?: number;
    documentSubTypeName?: string | undefined;
    documentFiles?: DocumentFileResponseDto[] | undefined;
}

export interface DocumentFilterResponseDtoListServiceResponse {
    data?: DocumentFilterResponseDto[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface DocumentIndexResponseDto {
    documentIndexId?: number;
    documentIndexName?: string | undefined;
    isRequried?: boolean | undefined;
}

export interface DocumentIndexResponseDtoListServiceResponse {
    data?: DocumentIndexResponseDto[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface DocumentIndexValueByDocumentIdResponseDto {
    documentIndexName?: string | undefined;
    value?: string | undefined;
}

export interface DocumentIndexValueByDocumentIdResponseDtoListServiceResponse {
    data?: DocumentIndexValueByDocumentIdResponseDto[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface DocumentResponseDto {
    documentId?: string;
    documentCode?: string | undefined;
    documentTypeName?: string | undefined;
    documentSubTypeName?: string | undefined;
    mainIndex?: string | undefined;
    searchIndex?: string | undefined;
    fileCount?: number | undefined;
    createdByUserId?: number | undefined;
    createdDate?: dayjs.Dayjs | undefined;
}

export interface DocumentResponseDtoListServiceResponse {
    data?: DocumentResponseDto[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface DocumentSearchResponseDto {
    documentId?: string;
    documentCode?: string | undefined;
    documentFileId?: string | undefined;
    urlLink?: string | undefined;
    isImage?: boolean;
}

export interface DocumentSearchResponseDtoListServiceResponse {
    data?: DocumentSearchResponseDto[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface DocumentSubTypeResponseDto {
    documentSubTypeId?: number;
    documentSubTypeName?: string | undefined;
    documentTypeId?: number | undefined;
}

export interface DocumentSubTypeResponseDtoListServiceResponse {
    data?: DocumentSubTypeResponseDto[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface DocumentTypeResponseDto {
    documentTypeId?: number;
    documentTypeName?: string | undefined;
}

export interface DocumentTypeResponseDtoListServiceResponse {
    data?: DocumentTypeResponseDto[] | undefined;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface UploadDocumentFilesResponseDto {
    documentFileId?: string;
    fileName?: string | undefined;
}

export interface UploadResponseDto {
    documentId?: string;
    files?: UploadDocumentFilesResponseDto[] | undefined;
}

export interface UploadResponseDtoServiceResponse {
    data?: UploadResponseDto;
    isSuccess?: boolean;
    message?: string | undefined;
    code?: number | undefined;
    exceptionMessage?: any | undefined;
    serverDateTime?: dayjs.Dayjs;
    totalAmountRecords?: number | undefined;
    totalAmountPages?: number | undefined;
    currentPage?: number | undefined;
    recordsPerPage?: number | undefined;
    pageIndex?: number | undefined;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result?: any
): any {
    if (result !== null && result !== undefined) throw result;
    else throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}
